# Numeric

## Introduction
In Python, **numeric types** are built-in data types used to store and manipulate numbers. There are three main numeric types:


| Type      | Description                        | Example         |
| --------- | ---------------------------------- | --------------- |
| `int`     | Integer numbers                    | `10`, `-5`, `0` |
| `float`   | Floating-point (decimal) numbers   | `3.14`, `-0.01` |
| `complex` | Complex numbers (real + imag part) | `2 + 3j`, `-1j` |


### `int` —Integer

* Whole numbers (no decimal point)
* Unlimited precision (arbitrary size)

```python
x = 42
print(type(x))  # <class 'int'>

big = 10**100   # Very large integer
print(type(big)) # <class 'int'>
```

### `float` — Floating-Point

* Numbers with a decimal point
* Internally based on IEEE 754 double-precision (64-bit)

```python
pi = 3.14159
print(type(pi))  # <class 'float'>
div = 1 / 3      
print(div)  # 0.333...
```

**Special float values:**

```python
float('inf')     # ∞
float('-inf')    # -∞
float('nan')     # Not a Number
```

### `complex` —Complex Numbers

* Numbers with **real** and **imaginary** parts
* Written as `a + bj` (use `j`, not `i`)

```python
z = 2 + 3j
print(type(z))     # <class 'complex'>
print(z.real)      # 2.0
print(z.imag)      # 3.0
```

## Type Conversion

You can convert each type of number to another type by build-function `int`, `float` and `complex`:

```python
int(3.5)        # 3
float(2)        # 2.0
complex(1, 2)   # (1+2j)
```

## Numeric Operations

Operators Supported by All Numeric Types:

* Arithmetic: `+`, `-`, `*`, `/`, `//`, `%`, `**`
* Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`

```python
a = 5
b = 2
print(a + b)    # 7
print(a / b)    # 2.5
print(a // b)   # 2 (floor division)
```

Here’s a clean and complete table of **numeric operations** in Python, including their **description**, **example result**, and **notes**, based on the built-in types: `int`, `float`, and `complex`.

**Numeric Operations Table in Python**

| **Operation**     | **Result**                               | **Notes**                            |
| ----------------- | ---------------------------------------- | ------------------------------------ |
| `-x`              | Negation of `x`                          | –                                    |
| `+x`              | `x` unchanged                            | Unary plus                           |
| `x + y`           | Sum of `x` and `y`                       | Works for all numeric types          |
| `x - y`           | Difference of `x` and `y`                | –                                    |
| `x * y`           | Product of `x` and `y`                   | –                                    |
| `x ** y` or `pow(x, y)`     | `x` to the power `y`           | Exponentiation (5)                   |
| `x / y`           | Quotient of `x` and `y` (float)          | Always returns float                 |
| `x // y`          | Floored quotient of `x` and `y`          | Discards fractional part             |
| `x % y`           | Remainder of `x / y`                     | Result has same sign as `y`          |
| `divmod(x, y)`    | Returns `(x // y, x % y)`                | Tuple result -> (x//y,x%y)           |
| `abs(x)`          | Absolute value of `x`                    | Also works for complex numbers       |
| `round(x,d)`      | Rounds `x` to the nearest integer        | e.g., `round(2.337,2)` -> 2.34        |
| `int(x)`          | Remove decimal part of `x`               | e.g., `int(-2.93)` -> -2        |
| `c.conjugate()`   | Conjugate of complex number `c`          | e.g., `(2+3j).conjugate() = 2-3j`    |

	 

**Notes:**

1. `//` performs **floor division**, e.g. `5 // 2 = 2`, `-5 // 2 = -3`
2. `%` uses Python’s **modulus rule**: the result has the **same sign as the divisor (`y`)**
3. `int(3.8)` → `3`; `int('7')` → `7`; `int('abc')` → raises error
4. `float('3.14')` → `3.14`
5. `pow(2, 3)` → `8`; works like `2 ** 3`; can also do modular exponentiation: `pow(2, 3, 5)` → `3`
6. `int()`, `float()`, and `complex()` are constructors for their respective types
7. You can find official documentation on [https://docs.python.org](https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex)


## Comparison Operators

### Comparison Operators in Python

In Python, **comparison operators** are used to compare values. These operators return **Boolean values**: `True` or `False`.

| **Operator** | **Meaning**              | **Example**        | **Result**                |
| ------------ | ------------------------ | ------------------ | ------------------------- |
| `==`         | Equal to                 | `3 == 3`           | `True`                    |
| `!=`         | Not equal to             | `4 != 5`           | `True`                    |
| `>`          | Greater than             | `7 > 2`            | `True`                    |
| `<`          | Less than                | `1 < 0`            | `False`                   |
| `>=`         | Greater than or equal to | `5 >= 5`           | `True`                    |
| `<=`         | Less than or equal to    | `6 <= 3`           | `False`                   |
| `is`         | **Object identity**      | `a is b`           | `True` if same object     |
| `is not`     | Negated object identity  | `a is not b`       | `True` if not same object |
| `in`         | Membership               | `'a' in 'abc'`     | `True`                    |
| `not in`     | Negated membership       | `'z' not in 'abc'` | `True`                    |


**Example Code**

```python
x = 10
y = 20

print(x == y)     # False
print(x != y)     # True
print(x < y)      # True
print(x >= y)     # False
```


### Chained Comparisons

Python supports **chaining** of comparisons:

```python
x = 5
print(1 < x < 10)     # True
print(1 < x and x < 10)  # Same result, more verbose
```

This is equivalent to:

```python
(1 < x) and (x < 10)
```

---

###  `is` vs `==`

| `==` | Compares **values**                    |
| ---- | -------------------------------------- |
| `is` | Compares **identity** (memory address) |

```python
a = [1, 2]
b = [1, 2]
print(a == b)    # True (same contents)
print(a is b)    # False (different objects)
```

### None

Use `is` and `is not` instead of `==` for `None`:

```python
x = None
y = 2
print(x is None) # True
print(x is not None) # False
print(y is None) # True
```
Why? Because `None` is a singleton, and identity checks (`is`) are more precise than equality checks (`==`).